# # 컴퓨터 시스템

## 1. 컴퓨터 시스템 구성 요소

- 하드웨어, 운영체제, 응용프로그램, 컴파일러, 사용자

- 사용자는 응용프로그램을 활용
- 응용프로그램은 곧바로 하드웨어 상에서 돌아가는게 아니라 운영체제 위에서 돌아간다.
- 하드웨어를 사용자들이 편안하게/효율적으로 사용하기 위한 기능을 제공해주는 것이 운영체제

# # 운영체제란?

- 이해하기는 어렵지 않다. 구현(개발)하는 것이 어려운거지.
- 하드웨어는 굉장히 빠르다. 빛의 속도로 처리 (다만 이렇게 빠른 하드웨어를 사용자가 응용프로그램을 통해 사용할 수 있도록 하드웨어 위에서 맡아서 처리해 주는 것이 운영체제이다.

## 1. 목적 (크게 두 가지)

- 사용자가 프로그램을 수행할 수 있도록 환경을 조성
    - 컴퓨터를 편리하게 사용 → `편리성`
    - 하드웨어를 효율적으로 사용 → `효율성`
- 그 외 부차적인 목적: 시스템의 효율적인 운용
- 효율성 ←`**상반된 관계**`→ 편리성
    - ex. 교실에 책상이 없는 것이 효율적인 청소에는 도움이 되지만 책상이 있어야 수업들을 때 편리하다.

## 2. 역할

- 다른 프로그램이 유용한 작업을 하기 위한 환경을 제공

### 자원 할당자(관리자)

- 컴퓨터는 사용자의 요구사항을 처리하기 위해 켜져있는 동안 **대기상태** 
→ 자원(resource)을 계속 붙잡고 있는 상태
- 사용자가 거의 동시에 처리된다고 느낄 수 있지만 이러한 처리는 운영체제가 자원할당을 매번 해주기 때문에 가능
- 자원이란?
    - CPU시간
    - 메모리공간 (**주기억장치**o, 하드디스크x)
    - 파일기억장치
    - 입출력장치 (마우스, 키보드,,)

### 제어프로그램

- 입출력장치와 사용자 프로그램을 제어 (흔히 IBM 360/67)

# # 운영체제의 발전과정

### No OS (1945)

- 운영체제 없이 시작 (과거에는 없어도 괜찮았기 때문)

### 일괄처리 (1955)

- 유사한 성격의 업무를 모아서 한꺼번에 처리
    - 지금도 이런 방식을 사용하고 있다 → **배치처리**
    - 항상 동일한 과정을 처리하도록 세팅되어 있는 것

### 다중처리 (1965)

- 멀티프로그래밍
- ex. 브라우저 띄워놓고 한글작업하는 것

### 가상기억장치 (1975)

- 기억장치를 모두 올려놓고 작업하다보니 기억장치가 매우 커져야 했다.
- 하지만 물리적으로 커지는 걸 의미하지 않음.
- 실제로 **한정된 메모리 안**에서 돌려야할 프로그램의 사이즈는 크다보니, **일부분씩 올려서 작업**하게 된다 → 가상기억장치
- 가상기억을 하기 위한 메모리구조가 등장

### 분산처리 (1985)

- 분산환경 → 데이터만 분리? 데이터와 운영체제를 모두 별도로 놓고 처리?
- 클라우드 컴퓨팅 환경, 모바일OS, Realtime OS (최근 ~)

# # 운영체제의 분류

### 제어 프로그램

- 처리프로그램의 실행과 기억장소나 데이터제어 또는 연속 처리 작업 스케줄 등 감시 기능
- `자료관리` 프로그램: 파일과 자료를 **표준화**하여 처리관리
    - 표준화를 통해 대량생산이 가능
- `작업관리` 프로그램: 업무처리후 **다른 업무 이행**을 위한 **준비 및 후속처리** 기능
    - 현재 업무를 끝내고 다른업무를 처리하기 위해서는 준비시간 및 후속처리가 필요하다
- `감시` 프로그램: 처리프로그램 실행과정과 전체 시스템동작상태 감시

### 처리 프로그램

- 제어프로그램하에서 특정문제를 해결하기 위한 데이터처리
- ex. 어셈블러, 컴파일러, 인터프리터 등 언어번역기, 연계편집기(linkage editor), 라이브러리 프로그램 등

# # 운영체제의 기능

### 관리기능

- `메모리 관리자`: 데이터 처리를 위한 저장 기능 관장 (주기억장치)
- `프로세스 관리자`: CPU를 언제 어디에 얼마나 할당해줄지 관장

### 컴퓨터의 시스템 자원 관리 기능

- 사용자와 컴퓨터 시스템간의 **인터페이스 기능 제공**
- 사용자들 간의 **H/W를 공동**으로 사용하게 함
- 사용자들 간의 **데이터를 공유**할 수 있게 함
- 사용자들 간의 **자원 스케줄링**을 담당
- **입출력의 보조 역할** 담당
- 컴퓨터 시스템의 **에러 처리** 담당

# # 컴퓨터 자원

## 1. 운영체제 관점의 컴퓨터 자원

### H/W 자원

- 기억장치
- 프로세서
- HDD
- 자기테이프
- 단말기
- 키보드 등

### S/W 자원

- 메시지
- 시그널
- 파일
- 프로그램
- DB등 공유 SW
- 등등 많음

## 2. 각 자원 관리자의 수행 과정

- 시스템 내 자원의 상태를 추적, 기억시킨다 
→ `누가 기억하고 있나?`: **자원관리자**
- 어떤 CPU에게 언제 어떤 자원을 얼마나 할당할 것인가를 결정하기 위한 정책 수립
- 요구된 자원 할당
- 사용이 끝난 자원 회수

# # 프로그램 실행을 위한 단계

- 각 단계별로 많은 관리자들의 수행이 필요

1. 키보드로부터 입력
    - by. 장치 관리자
2. 키보드 분석하여 명령 구성
3. 사용자 명령 인터페이스로 전송
4. 명령어의 유효성 판단
    - by. 프로세서 관리자
5. 승인 메세지를 비디오 모니터로 송신 → 사용자가 인식
6. 명령을 접수하여 수행 
→ 내용을 디스크로부터 가져와야 하는지 or 메모리에 적재되어 있는지 판단
→ 해당 관리자를 호출
    - by. 파일 관리자/메모리 관리자
7. 디스크인 경우 디스크의 정확한 위치를 계산 
→ 장치관리자에 송신
→ 장치관리자는 디스크로부터 읽어서 메모리 관리자에 송신
    - 메모리 관리자는 사용 가능한 공간에 적재
    - 프로세서 관리자의 프로그램 실행에 따른 진행 및 위치 정보 추적
    - 수행 완료시 결과 메시지를 프로세서 관리자에 송신
    - 프로세서 관리자는 결과 메세지를 장치 관리자에 송신
    - 장치 관리자는 비디오 모니터에 표시
    

# # 운영체제 발전 형태

> 초기 → 컴퓨터 하드웨어만 존재
> 

### 특징

- 프로그램 시작주소 적재, 데이터 적재, 실행 등
- 수조작에 따른 대화적 성격 (hands-on interactive nature)

### 문제점

- 소요시간 예측하여 작업 할당 → `일찍 끝난 경우 유휴상태 발생`
- H/W, S/W 개발하여 공통기능: 어셈블리어로 작성하여 사용
- 다른 종류의 작업처리시 준비 시간 발생 → 해결책: `batch처리`
- 다른 작업으로 넘어가는 유휴시간 없애도록 자동 절차 생성 → `상주모니터 개념`
    - `상주모니터의 기억장치`
        - 장치구동기: 입출력 장치를 위한 것

### 유휴시간을 줄이는게 목적 → 상주모니터 (Resident Moniter)

- 온라인 연산
    - 카드 판독기 → CPU → 라인 프린터
- 입출력 장치
    - 카드판독기(분당 1000장의 카드읽기), 라인프린터(msec)
- 문제점
    - **입출력 장치의 느린** **속도**
    - **CPU 처리 속도**
    - **카드판독기 (분당 1000장의 카드읽기)**
- 해결책
    - `오프라인 연산`
    - **카드판독기 → 테이프 (임시기억장치) → 장치구동기 → CPU → 테이프 → 장치구동기 → 라인프린터**

### 장치의 독립성

- **프로그램과 입출력 장치가 서로 다르게 수행되는 것**
    - ex. 프린터 실행해두고 컴퓨터로 다른 작업 수행 가능
- DB에서도 독립성 언급

# < **용어 >**

### **`Buffering`**

- 입출력 장치의 느린 속도를 보완하는 방법
- 디스크로부터 필요한 레코드를 미리 읽어 MM에 저장하여 **CPU가 기다리지 않도록** 레코드들이 저장되는 곳 
(CPU는 데이터가 버퍼까지 아직 안왔으면 기다리지 않고 다른 작업을 한다)
- MM의 일부가 버퍼. 이 과정 ****
- **버퍼링이 성능상 미치는 영향** → 버퍼링은 현재에도 많이 사용되는 기능
    - 주로 한 레코드를 처리하는데 걸리는 시간을 일정하게 해줌
    - **CPU와 입출력 장치(ex.프린터)의 평균 속도(초당 레코드수)가 같다면?**
        - Full speed로 비슷하게 처리 가능
    - **CPU가 평균적으로 입출력 장치보다 빠르다면 버퍼링은? ←이게 당연히 더 일반적**
        - 쓸모없음
        - 버퍼는 항상 비어있는 상태 / CPU는 항상 대기 상태(버퍼가 찰 때까지) ⇒ **입출력 바운드**(튕기는 현상)가 발생됨
    - **CPU가 평균적으로 입출력 장치보다 느리다면 버퍼링은?**
        - 위와 반대로 **CPU 바운드** 작업
    - **초기 시스템의 형태?**
        - 입출력 바운드 작업 처리가 주류
    - **현대 시스템의 형태?**
        - 비슷
    

### **`Spooling`: Simultaneous Peripheral Operation On-Line**

- 디스크를 매우 큰 버퍼처럼 사용
- 가능한 **미리** 입력 장치로부터 **읽어**들여 출력 장치가 받을 수 있을 때까지 출력 파일을 **저장**하기 위함
- 장점 → 한 작업의 입출력과 다른 작업의 계산을 중복
    - ex. 한 작업의 출력을 인쇄하는 동안 다른 작업의 입력을 읽어 들임
- FCFS 방법으로 서비스

### `**Program**` vs. `**Process**`

- 메모리에 올라오기 전까지는 그냥 프로그램(하드디스크) → 메모리로 로딩되면 프로세스(메모리)

# # 운영체제의 종류(분류)

> **분류기준**: 데이터 `입력` 방식 / 데이터 `처리` 방식
> 

## 1. 데이터 입력 방식에 따른 분류

### (1) 일괄처리(Batch) 시스템

- 1950년대 초기 컴퓨터 처리 형태
- **일정기간, 일정량의 자료를 모아 한번에 처리**하는 방식
- 초기 운영체제 형태에서는 CPU 유휴시간 발생 → 낭비로 이어짐 → 이를 줄이고자 한 번에 모아서 처리
- 자료 발생에서부터(Setup time 포함) 최종 결과 획득까지 시간(Turnaround time)이 매우 길다는 단점
- 현재의 개념은 작업 실행 중 사용자와 작업간 대화 부족
- 오류 수정 → 스냅샷 덤프(snapshot dump)를 이용해 정적으로 수행

### (2) 대화식(interactive) 시스템

## 2. 데이터 처리 방식에 따른 분류

### (1) 시분할(Time sharing) 시스템

- **적당한 비용으로 컴퓨터를 대화적으로 사용**하려는 노력의 결과
- **TS OS**
    - CPU **스케줄링**과 **다중프로그래밍**을 사용해서 **각 사용자에게** **컴퓨터를 시간적으로 분할하여 조금씩 나누어 주는 것**
    - 단, 너무 긴 시간을 할당해주게 되면 각 사용자가 기다리는 시간이 너무 길어지므로 아주 짧은 시간만 할당 (ex. 1초씩 할당해주더라도 60명이면 60번째 사용자는 1분을 기다려야 하니까,, 1초도 길다)
- 1960년 이전에 아이디어화
- 1970년 초 이후 일반화
- 현재 OS의 주요 연구분야
- 고려해야할 중요 사항?
    - 기억장치 관리기법
    - 디스크 스케줄링 기법
    - CPU 스케줄링 기법
    
    ⇒ 스와핑
    

### (2) 실시간(real-time) 처리 시스템

- 처리 요구 발생시 즉시 처리하여 그 결과를 출력 혹은 요구 응답
- **정의된 시간적 제약을 받는 시스템**
    - **실시간 →** 반드시 **‘**정의된 시간적 제약’이라는 개념이 포함되어야 한다
    - 특수 목적을 위한 응용에서 제어장치로 활용
        - ex. 비행기 좌석 예약, 화학 공장, 은행 등

### (3) 혼합(hybrid) 시스템 = 다중프로그래밍(Multiprogramming) 시스템

- 1960년대 초의 처리형태
- **CPU가 수행할 것을 항상 가지도록**하여 **이용률을 증진**시키기 위함
    - cf. 배치 시스템에서는 Setup time(일괄처리할 작업을 모으는 시간)에 CPU가 놀고 있음
    - CPU가 노는 것은 낭비이니 놀지 않고 계속 일을하도록 만드는 것이 다중프로그래밍의 목적
- 여러 개의 작업을 준비 상태로 두어 처리
- 이때 고려해야할 중요 사항은?
    - 기억장치 경영
        - 기억장치에 있는 여러 작업 중 필요한 것 하나를 바로 꺼내기(병행처리) 위해서는 이 기억장치를 관리하는 법이 중요
    - CPU 스케줄링
    - 장치 스케줄링
    - 데드락(deadlock) 핸들링
        - 처리가 어딘가에 막혀서 리소스를 계속 잡고 있게 되면 어떻게 처리할 것인지
    - 동시성 제어
    - 보호(protection) → 기억장치를 구분해서 쓰기 때문에 그에 대한 보호 필요
- 현대 컴퓨터 연구의 중심 주제

> **다중처리시스템 (Multiprocessing System)**
> 
- CPU를 여러 개로 구성하는 기법
- 목적: **신뢰성**(Reliability) & **컴퓨터 능력**(Throughput)의 증대
1. **강결합**(tightly coupled) 다중처리 시스템
    - 기억장치(메모리 = 저장장치)는 공유하며, I/O장치(입출력 = 처리기)는 따로 지님

    
2. **약결합**(Loosely coupled) 다중처리 시스템
    - 기억장치(메모리)와 I/O장치(입출력)를 각각 지님

    

> **분산처리시스템 (Distributed Processing System)**
> 
- 1970년대 중반 출현
- 통신을 통해 여러 컴퓨터와 단말기에 **작업과 자원을 분산**하여 처리하는 방식
- 독립적인 처리 능력을 가진 컴퓨터 시스템 및 데이터들이 지역적으로 분산되어 일을 처리, 상호협력하는 시스템
- 분산처리시스템 설계 이유
    - 자원공유
    - 연산속도 증가 → 여러 대가 나눠서 처리하므로 각자의 부담이 줄어 속도가 빨라짐
    - 신뢰성 향상 → 한 대에 문제가 생기더라도 공유하고 있는 다른 컴퓨터에는 데이터 유지
    - 통신 기능
    

> **병렬처리시스템 (Parallel Processing Systemp)**
> 
- 입.출력 채널 혹은 프로세서가 둘 이상의 프로세스를 동시에 수행
- 목적: 단위시간당 **처리 작업 양 증대 및 처리 능력 증대**
- N개 프로세서 사용시 1개보다 일 처리량?
    - 1 unit < `N process` < N unit
- 오버헤드 발생(상호 협력 및 대기 등으로 인해)

> **멀티미디어시스템 (Multimedia System)**
> 
- 환경이 멀티미디어 응용 변화를 가능케 함으로써 이용하는 시스템
1. 온라인 응용
    - 입출력 요구에 연속성, 동기화 등 시간적 제약 만족시켜야함
2. 오프라인 응용
    - 정지영상 검색 등

> **임베디드시스템 (Embeded System)**
> 
- 일반 컴퓨터가 아님 → 구현 할 수 없음
- 마이크로프로세서에 미리 정해진 **특정기능을 수행할 수 있는 소프트웨어를 내장**시킨 것
- **SoC(System-on-Chip)**
    - 공장 및 가정 자동화에 필요한 자동제어, 디지털 가전기기, 자동 센서장비 등 핵심 소프트웨어 산업에 응용
- **사용범위**
    - 멀티미티어 처리, 다중작업 및 실시간 처리 강화에 따른 유무선 통신 및 N/W와의 접목으로 제조, 유통, 금융, 서비스 산업, 항공, 우주, 국방, 의료, 멀티미디어 통신 및 에너지 개발 등 (모든 시스템에 들어가있음)
- **특징**
    - No HDD (하드웨어 없음), RAM과 ROM에 OS(CE, Embedded Linux, 팜OS 등)
    - 실시간(real-time) 처리 지원
    - 경량화, 저전력 지원, 자원의 효율적관리를 위해 하드웨어와 최적화기술 지원
    - 특정 시스템의 실행을 목적으로 개발되는 소프트웨어
    - 네트워크 및 멀티미디어 처리기능 지원
    - 디지털 TV, PDA 및 스마트폰 등과 같은 임베디드 시스템 지원
- 임베디드 시스템에 사용되는 **내장형 운영체제**
    - RealTime 운영체제, Windows CE, 팜OS 등